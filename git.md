# Шпаргалка по GIT

* Клонировать существующий репозиторий
```ch
$ git clone ssh://user@domain.com/repo.git
```
* Создать локально новый репозиторий
```ch
$ git init
```
## Локальные изменения

* Файлы в рабочей директории были изменены
```ch
$ git status
```
* Изменения в отслеживаемых файлах
```ch
$ git diff
```
* Добавить все текущие изменения в следующий коммит
```ch
$ git add .
```
* Добавить некоторые изменения в <файле> в следующий коммит
```ch
$ git add -p <файл>
```
* Зафиксировать все локальные изменения в отслеживаемых файлах
```ch
$ git commit -a
```
* Закоммитить ранее добавленные изменения
```ch
$ git commit
```
* Изменить последний коммит
```ch
* Не изменяйте опубликованные коммиты!
$ git commit --amend
```
* История коммитов
```ch
* Показать всю историю коммитов начиная с последних
$ git log
```
* Показать историю изменений определенного файла
```ch
$ git log -p <файл>
```
* Кто, какие и когда изменения вносил в <файл>
```ch
$ git blame <файл>
```
## Ветки и теги

* Список всех существующих веток
```ch
$ git branch -av
```
* Переключение в HEAD ветки
```ch
$ git checkout <ветка>
```
* Создать новую ветку на основе текущей HEAD
```ch
$ git branch <новая-ветка>
```
* Создать новую ветку и сразу переключится в нее
```ch
$ git checkout -b <новая-ветка>
```
* Создать новую отслеживаемую ветку на основе удаленной ветки
```ch
$ git checkout --track <репо/ветка>
```
* Удалить локальную ветку
```ch
$ git branch -d <ветка>
```
* Присвоить текущему коммиту тег
```ch
$ git tag <имя-тега>
```
## Обновление и публикация

* Список всех настроенных удаленных репозиториев
```ch
$ git remote -v
```
* Показать информацию об удаленном репозитории
```ch
$ git remote show <репо>
```
* Добавить новый удаленный репозиторий с именем <remote>
```ch
$ git remote add <короткое-имя> <url>
```
* Скачать все изменения из <remote>, но не интегрировать их в HEAD
```ch
$ git fetch <репо>
```
* Скачать изменения и сразу слить/интегрировать их в HEAD
```ch
$ git pull <репо> <ветка>
```
* Опубликовать локальные изменения в удаленном репозитории
```ch
$ git push <репо> <ветка>
```
* Удалить ветку в удаленном репозитории
```ch
$ git branch -dr <репо/ветка>
```
* Опубликовать теги
```ch
$ git push --tags
```
## Слияние и перемещение

* Слить <ветку> с текущей HEAD
```ch
$ git merge <ветка>
```
* Переместить вашу текущую HEAD на <ветку>
```ch
* Не перемещайте опубликованные коммиты!
$ git rebase <ветка>
```
* Отменить перемещение
```ch
$ git rebase --abort
```
* Продолжить перемещение после разрешения конфликтов
```ch
$ git rebase --continue
```
* Используйте свой настроенный инструмент слияния для разрешения конфликтов
```ch
$ git mergetool
```
Используйте свой редактор для решения конфликтов и (после разрешения) отметить файлы как разрешенные
```ch
$ git add <разрешенный-файл>
$ git rm <разрешенный-файл>
```
## Отмена Удалить все локальные изменения в рабочем каталоге
```ch
$ git reset --hard HEAD
```
* Удалить локальные изменения в отдельном <файле>
```ch
$ git checkout HEAD <файл>
```
* Откатить коммит (но проще создать новый коммит с противоположными изменениями)
```ch
$ git revert <коммит>
```
* Сбросить головной указатель HEAD на предыдущий коммит
```ch
…и отменить все изменения после него
$ git reset --hard <коммит>
…и сохранить все изменения как незакоммиченые
$ git reset <коммит>
…и сохранить неотслеживаемые локальные изменения
$ git reset --keep <коммит>
```
* Для обучения https://git-scm.com/book/ru/v1
# Лучшие практики
Добавляйте в коммит связанные изменения
Коммит должен содержать связанные изменения. Например, правки двух разных багов должны быть в двух разных коммитах. Маленькие коммиты помогают другим разработчикам проще понимать изменения и откатить их, если что-то пойдет не так. 
При помощи таких инструментов, как область подготовленных файлов и возможности добавлять только часть изменений из файла, Git упрощает создание очень мелких коммитов.
# Делайте коммиты часто
Частая публикация коммитов позволяет вам делать их маленькими и, опять же, помогает добавлять в коммит только связанные изменения. Более того, почаще делитесь своим кодом с остальными. Таким образом, всем будет легче, если вы чаще будете интегрировать свои изменения и это поможет избежать конфликтов при слиянии. Большие и редкие коммиты усложняют жизнь и затрудняет решение конфликтов.
Не публикуйте коммиты с незаконченной работой
Вы должны коммитить код, только если он завершен. Это не значит, что вы должны полностью закончить работу над большой задачей перед коммитом. Наоборот: разделите работу над задачей на логические части и помните о своевременной и частой публикации коммитов. Но не публикуйте изменения только чтобы в репозитории что-то появилось перед вашим уходом из офиса в конце рабочего дня. Если вы собираетесь опубликовать коммит только потому, что вам нужна чистая рабочая область (при переключении веток, перед pull и т.д.) присмотритесь к функци “stash”.
# Тестируйте код перед коммитом
Не поддавайтесь искушению закоммитить что-то, что на ваш взгляд уже готово. Протестируйте внимательно и убедитесь в том, что работа закончена и в коде нет ошибок (на сколько это может проверить один человек). В то время, как полусырые изменения в вашем локальном репозитории вы можете простить себе самому, вы должны тщательно протестировать код перед тем как публиковать/делится своим кодом с другими.
# Пишите хорошие комментарии
Начните свое сообщение с краткого резюме своих изменений (ориентируйтесь на 50 символов). Отделите это сообщение от основного текста пустой строкой. В теле сообщения следует дать подробные ответы на следующие вопросы:
Какова была причина изменений?
# В чем отличие от предыдущего коммита?
Используйте слова в настоящем времени («меняется», не «был изменен» или «изменения») чтобы при git merge сгенерированное сообщение выглядело хорошо.
Система контроля версий не хранилище бекапов
Хранение резервных копий файлов на удаленном сервере это только приятный побочный эффект использования системы контроля версий. Но вы не должны использовать Git только для этого. При работе с системой обратите особое внимание на семантику коммитов (смотри пункт 1) — вы не должны просто запихивать файлы в репозиторий.
# Используйте ветки
Ветвление — это одна из самых мощных возможностей Git. И это не случайно: быстрое и простое ветвление было требованием номер один с самого начала. Ветки являются самым простым инструментом чтобы избежать смешивания разных линий разработки. Вы должны повсеместно использовать ветки в своей разработке: для работы над новыми задачами, для исправления багов, для идей…
# Согласуйте рабочий процесс
Git позволяет выбрать из большого количества рабочих процессов: длинные ветки, тематические ветки, слияние или перемещение, gitflow… Что из этого выберите вы зависит от нескольких факторов: ваш проект, ваше общее направление развития, среда разработки и (возможно самое важное) ваши личные предпочтения и предпочтения вашей команды. Что бы вы не выбрали убедитесь, что все следуют процессу, который был согласован.
